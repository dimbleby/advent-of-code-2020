use std::collections::HashSet;
use std::str::FromStr;

struct Rule {
    index: usize,
    choices: Vec<Production>,
}

impl Rule {
    fn new(index: usize, choices: Vec<Production>) -> Self {
        Self { index, choices }
    }
}

enum Production {
    Terminal(char),
    NonTerminal(Vec<usize>),
}

#[derive(Debug)]
struct ParseError;

impl From<std::num::ParseIntError> for ParseError {
    fn from(_err: std::num::ParseIntError) -> Self {
        ParseError
    }
}

impl FromStr for Production {
    type Err = ParseError;

    // Expects strings like "\"a\"", or "3 13 2".
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let production = if s.starts_with('"') {
            let c = s.chars().nth(1).ok_or(ParseError)?;
            Self::Terminal(c)
        } else {
            let rules = s
                .split(' ')
                .map(|word| word.parse())
                .collect::<Result<Vec<_>, _>>()?;
            Self::NonTerminal(rules)
        };
        Ok(production)
    }
}

impl FromStr for Rule {
    type Err = ParseError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let mut parts = s.split(": ");
        let index: usize = parts.next().ok_or(ParseError)?.parse()?;
        let choices: Vec<Production> = parts
            .next()
            .ok_or(ParseError)?
            .split(" | ")
            .map(|word| word.parse())
            .collect::<Result<Vec<_>, _>>()?;
        let rule = Rule::new(index, choices);
        Ok(rule)
    }
}

fn is_valid(rules: &[Rule], input: &str) -> bool {
    // Following <https://en.wikipedia.org/wiki/CYK_algorithm>: is the substring of length l,
    // starting at s, generated by rule v?
    let mut productions: HashSet<(usize, usize, usize)> = HashSet::new();

    for (s, c) in input.chars().enumerate() {
        for rule in rules {
            for choice in &rule.choices {
                match choice {
                    Production::Terminal(t) if t == &c => {
                        productions.insert((1, s, rule.index));
                    }
                    _ => {}
                }
            }
        }
    }

    let n = input.len();
    for l in 2..=n {
        for s in 0..n - l + 1 {
            for rule in rules {
                for choice in &rule.choices {
                    for p in 1..l {
                        if let Production::NonTerminal(indexes) = choice {
                            if productions.contains(&(p, s, indexes[0]))
                                && productions.contains(&(l - p, s + p, indexes[1]))
                            {
                                productions.insert((l, s, rule.index));
                                break;
                            }
                        }
                    }
                }
            }
        }
    }

    productions.contains(&(n, 0, 0))
}

pub(crate) fn day19() {
    // Hand-edited the input to normalize a couple of rules...
    let input = std::fs::read_to_string("data/day19.txt").unwrap();
    let mut sections = input.split("\n\n");
    let rules: Vec<Rule> = sections
        .next()
        .unwrap()
        .lines()
        .map(|line| line.parse().unwrap())
        .collect();

    let strings: Vec<&str> = sections.next().unwrap().lines().collect();

    let valid = strings.iter().filter(|s| is_valid(&rules, s)).count();
    println!("Part one answer is {}", valid);

    // Again, hand-edited the input to normalize a couple of rules...
    let input = std::fs::read_to_string("data/day19b.txt").unwrap();
    let mut sections = input.split("\n\n");
    let rules: Vec<Rule> = sections
        .next()
        .unwrap()
        .lines()
        .map(|line| line.parse().unwrap())
        .collect();

    let valid = strings.iter().filter(|s| is_valid(&rules, s)).count();
    println!("Part two answer is {}", valid);
}
